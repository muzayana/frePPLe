<?xml version="1.0" encoding="UTF-8" ?>
<plan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <name>Forecast benchmark model</name>
  <description>
  The M3-competition benchmark test for time series forecasts is run to compare
  the results with industry standard solutions.
  Dataset:
     http://forecastingprinciples.com/files/xls/M3C.xls
  Results:
     http://forecastingprinciples.com/files/Makridakia-The%20M3%20Competition.pdf
     http://forecasters.org/resources/time-series-data/m3-competition/
  </description>
  <current>2009-01-01T00:00:00</current>

  <!--
  This calendar defines the forecasting buckets.
  -->
  <calendars>
    <calendar name="planningbuckets">
      <buckets>
        <bucket start="2009-01-01T00:00:00" end="2009-02-01T00:00:00" value="1"/>
        <bucket start="2009-02-01T00:00:00" end="2009-03-01T00:00:00" value="1"/>
        <bucket start="2009-03-01T00:00:00" end="2009-04-01T00:00:00" value="1"/>
        <bucket start="2009-04-01T00:00:00" end="2009-05-01T00:00:00" value="1"/>
        <bucket start="2009-05-01T00:00:00" end="2009-06-01T00:00:00" value="1"/>
        <bucket start="2009-06-01T00:00:00" end="2009-07-01T00:00:00" value="1"/>
        <bucket start="2009-07-01T00:00:00" end="2009-08-01T00:00:00" value="1"/>
        <bucket start="2009-08-01T00:00:00" end="2009-09-01T00:00:00" value="1"/>
        <bucket start="2009-09-01T00:00:00" end="2009-10-01T00:00:00" value="1"/>
        <bucket start="2009-10-01T00:00:00" end="2009-11-01T00:00:00" value="1"/>
        <bucket start="2009-11-01T00:00:00" end="2009-12-01T00:00:00" value="1"/>
        <bucket start="2009-12-01T00:00:00" end="2010-01-01T00:00:00" value="1"/>
        <bucket start="2010-01-01T00:00:00" end="2010-02-01T00:00:00" value="1"/>
        <bucket start="2010-02-01T00:00:00" end="2010-03-01T00:00:00" value="1"/>
        <bucket start="2010-03-01T00:00:00" end="2010-04-01T00:00:00" value="1"/>
        <bucket start="2010-04-01T00:00:00" end="2010-05-01T00:00:00" value="1"/>
        <bucket start="2010-05-01T00:00:00" end="2010-06-01T00:00:00" value="1"/>
        <bucket start="2010-06-01T00:00:00" end="2010-07-01T00:00:00" value="1"/>
        <bucket start="2010-07-01T00:00:00" end="2010-08-01T00:00:00" value="1"/>
        <bucket start="2010-08-01T00:00:00" end="2010-09-01T00:00:00" value="1"/>
      </buckets>
    </calendar>
  </calendars>
  <demands>
    <demand name="test" xsi:type="demand_forecast" discrete="false">
      <calendar name="planningbuckets" />
    </demand>
  </demands>

<?python
import csv

theitem = frepple.item(name="item")
thecustomer = frepple.customer(name="customer")
thecalendar = frepple.calendar(name="planningbuckets")
thebuckets = [ i.start for i in thecalendar.buckets ]
fcst = frepple.demand_forecast(name="test", item=theitem, customer=thecustomer, calendar=thecalendar, discrete=False)

def measure(param, loglevel):

  solver = frepple.solver_forecast(
    name="forecasting",
    loglevel=0,
    SmapeAlfa=0.96,
    Iterations=15,
    Skip=5,
    SingleExponential_minAlfa=0.01,
    SingleExponential_maxAlfa=0.8,
    DoubleExponential_minAlfa=0.01,
    DoubleExponential_maxAlfa=0.8,
    DoubleExponential_minGamma=0.01,
    DoubleExponential_maxGamma=0.8,
    DoubleExponential_dampenTrend=0.8,
    Seasonal_minAlfa=0.02,
    Seasonal_maxAlfa=0.25,
    Seasonal_minBeta=0.02,
    Seasonal_maxBeta=0.25,
    Seasonal_gamma=0.03,
    Seasonal_minPeriod=2,
    Seasonal_maxPeriod=15,
    Seasonal_minAutocorrelation=0.5,
    Seasonal_maxAutocorrelation=0.8,
    Seasonal_dampenTrend=0.7,
    Outlier_maxDeviation=2
    )

  fcstdmd = None
  totalsmape = {
    'total':0, '1':0, '2':0, '3':0, '4':0, '5':0, '6':0, '8':0, '12':0, '15':0, '18':0,
    '1-4':0, '1-6':0, '1-8':0, '1-12':0, '1-15':0
    }
  countsmape = totalsmape.copy()

  for row in csv.reader(open("M3data.csv", "rt")):

    # Skip comment lines
    if row[0].startswith('#'): continue

    # Intro
    if loglevel >= 2:
      print("\n%s\t%s\t%s\t%s" % (row[0], row[3], row[1], row[2]))

    # Generate forecast
    data = [ float(i) for i in row[6:6+int(row[1])-int(row[2])] ]
    test = [ float(i) for i in row[6+int(row[1])-int(row[2]):6+int(row[1])] ]
    solver.timeseries(fcst, data, thebuckets)

    # Evaluate the sMAPE error in the future buckets
    if fcstdmd == None:
      fcstdmd = []
      for i in frepple.demands():
        if not isinstance(i, frepple.demand_forecastbucket): continue
        fcstdmd.append(i)
    smape = 0
    cnt = 0
    results = ['frePPLe', row[0], row[2]]
    for i in test:
      results.append("%.2f" % fcstdmd[cnt].quantity)
      localsmape = abs(i - fcstdmd[cnt].quantity) / (i + fcstdmd[cnt].quantity) * 200
      cnt += 1
      totalsmape['total'] += localsmape
      countsmape['total'] += 1
      if cnt == 1:
        totalsmape['1'] += localsmape
        countsmape['1'] += 1
      if cnt == 2:
        totalsmape['2'] += localsmape
        countsmape['2'] += 1
      if cnt == 3:
        totalsmape['3'] += localsmape
        countsmape['3'] += 1
      if cnt == 4:
        totalsmape['4'] += localsmape
        countsmape['4'] += 1
      if cnt == 5:
        totalsmape['5'] += localsmape
        countsmape['5'] += 1
      if cnt == 6:
        totalsmape['6'] += localsmape
        countsmape['6'] += 1
      if cnt == 8:
        totalsmape['8'] += localsmape
        countsmape['8'] += 1
      if cnt == 12:
        totalsmape['12'] += localsmape
        countsmape['12'] += 1
      if cnt == 15:
        totalsmape['15'] += localsmape
        countsmape['15'] += 1
      if cnt == 18:
        totalsmape['18'] += localsmape
        countsmape['18'] += 1
      if cnt <= 4:
        totalsmape['1-4'] += localsmape
        countsmape['1-4'] += 1
      if cnt <= 6:
        totalsmape['1-6'] += localsmape
        countsmape['1-6'] += 1
      if cnt <= 8:
        totalsmape['1-8'] += localsmape
        countsmape['1-8'] += 1
      if cnt <= 12:
        totalsmape['1-12'] += localsmape
        countsmape['1-12'] += 1
      if cnt <= 15:
        totalsmape['1-15'] += localsmape
        countsmape['1-15'] += 1
    if loglevel >= 2:
      print("\t".join(["Actuals", row[0], row[2]] + ["%.2f" % x for x in test]))
      print("\t".join(results))

  # Print the results
  if loglevel >= 1:
    print("smape 1: %.2f" % (totalsmape['1'] / countsmape['1']))
    print("smape 2: %.2f" % (totalsmape['2'] / countsmape['2']))
    print("smape 3: %.2f" % (totalsmape['3'] / countsmape['3']))
    print("smape 4: %.2f" % (totalsmape['4'] / countsmape['4']))
    print("smape 5: %.2f" % (totalsmape['5'] / countsmape['5']))
    print("smape 6: %.2f" % (totalsmape['6'] / countsmape['6']))
    print("smape 8: %.2f" % (totalsmape['8'] / countsmape['8']))
    print("smape 12: %.2f" % (totalsmape['12'] / countsmape['12']))
    print("smape 15: %.2f" % (totalsmape['15'] / countsmape['15']))
    print("smape 18: %.2f" % (totalsmape['18'] / countsmape['18']))
    print("smape 1-4: %.2f" % (totalsmape['1-4'] / countsmape['1-4']))
    print("smape 1-6: %.2f" % (totalsmape['1-6'] / countsmape['1-6']))
    print("smape 1-8: %.2f" % (totalsmape['1-8'] / countsmape['1-8']))
    print("smape 1-12: %.2f" % (totalsmape['1-12'] / countsmape['1-12']))
    print("smape 1-15: %.2f" % (totalsmape['1-15'] / countsmape['1-15']))
    print("smape total: %.2f" % (totalsmape['total'] / countsmape['total']))
  return (totalsmape, countsmape)

# ACTUAL TEST
result = measure(0, 2)
if round(result[0]['1'] / result[1]['1'], 2) > 9.70:
  raise Exception("Failure: Short term forecast error is higher than expected.")
if round(result[0]['total'] / result[1]['total'], 2) > 18.80:
  raise Exception("Failure: Long term forecast error is higher than expected.")
if round(result[0]['total'] / result[1]['total'], 2) > 14.08:
  raise Exception("Failure: Long term forecast error is higher than expected.")
print("Forecast errors are matching our expected scrore.")

# PARAMETER TUNING LOOP
# Quickly test a range of parameter values. The measure function needs to
# be edited to use the parameter being passed to it.
#print("\tsmape 1\tsmape all")
#for param in [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
#   result = measure(param, 0)
#   print("%s\t%.2f\t%.2f" % (param, result[0]['1'] / result[1]['1'], result[0]['total'] / result[1]['total']))
?>
</plan>
